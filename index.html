<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Dual Deck Vinyl Tempo Helper</title>
<style>
  :root {
    color-scheme: dark;
    --bg: #000;
    --text: #f5f5f5;
    --accent: #2d9cff;
    --track: #303030;
    --tick: #6a6a6a;
    --tick-strong: #8c8c8c;
    --ghost: #8c8c8c;
  }
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0;
    font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 2rem 1rem 4rem;
    gap: 2rem;
  }
  h1 {
    font-size: clamp(1.5rem, 2vw + 1rem, 2.8rem);
    margin: 0;
    text-align: center;
    letter-spacing: 0.08em;
  }
  .app {
    width: min(1200px, 100%);
    display: grid;
    gap: 2rem;
  }
  .top-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    justify-content: center;
    align-items: center;
  }
  .top-controls button,
  .top-controls .range-label {
    background: #111;
    border: 1px solid #333;
    color: var(--text);
    padding: 0.6rem 1rem;
    border-radius: 999px;
    font-size: 0.95rem;
    cursor: pointer;
    transition: background 0.2s ease;
  }
  .top-controls button:hover,
  .deck button:hover {
    background: #1b1b1b;
  }
  .top-controls .range-label {
    cursor: default;
  }
  .decks {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 2rem;
  }
  .deck {
    background: #111;
    border: 1px solid #1f1f1f;
    border-radius: 18px;
    padding: 1.5rem;
    display: grid;
    gap: 1.5rem;
  }
  .deck header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 0.6rem;
  }
  .deck header h2 {
    margin: 0;
    font-size: 1.4rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
  }
  .tempo-display {
    display: grid;
    gap: 0.35rem;
    font-size: 0.95rem;
  }
  .tempo-display strong {
    font-size: 1.2rem;
  }
  .bpm-control {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
  }
  .bpm-control button {
    width: 2.5rem;
    height: 2.5rem;
    border-radius: 50%;
    border: 1px solid #2a2a2a;
    background: #1a1a1a;
    color: var(--text);
    font-size: 1.2rem;
    cursor: pointer;
  }
  .bpm-control input {
    width: 5.5rem;
    background: #000;
    border: 1px solid #444;
    border-radius: 0.6rem;
    padding: 0.4rem 0.6rem;
    color: var(--text);
    font-size: 1.1rem;
    text-align: center;
  }
  .slider-area {
    position: relative;
    display: flex;
    justify-content: center;
  }
  .fader {
    position: relative;
    width: 120px;
    display: flex;
    justify-content: center;
  }
  .fader-track {
    position: relative;
    width: 72px;
    height: 420px;
    background: linear-gradient(180deg, #070707, #0f0f0f);
    border-radius: 999px;
    border: 1px solid #1c1c1c;
    display: flex;
    justify-content: center;
    overflow: hidden;
  }
  .track-inner {
    position: relative;
    width: 100%;
  }
  .tick {
    position: absolute;
    left: 0;
    width: 100%;
    display: flex;
    align-items: center;
    pointer-events: none;
  }
  .tick::before {
    content: "";
    display: block;
    height: 1px;
    background: var(--tick);
    width: 18px;
    margin-left: 10px;
  }
  .tick.major::before {
    width: 28px;
    background: var(--tick-strong);
  }
  .tick.zero::before {
    height: 3px;
    background: var(--accent);
  }
  .tick-label {
    margin-left: 42px;
    font-size: 0.75rem;
    color: #b5b5b5;
  }
  .fader-track .extreme {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    font-size: 1.1rem;
    color: #7b7b7b;
  }
  .fader-track .extreme.top {
    top: 12px;
  }
  .fader-track .extreme.bottom {
    bottom: 12px;
  }
  .ghost-line {
    position: absolute;
    left: 12px;
    right: 12px;
    border-top: 1px dashed var(--ghost);
    opacity: 0.6;
    pointer-events: none;
  }
  .thumb {
    position: absolute;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 60px;
    height: 36px;
    border-radius: 24px;
    background: var(--accent);
    border: 2px solid #0b5fa5;
    cursor: grab;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    letter-spacing: 0.05em;
    color: #000;
    box-shadow: 0 6px 16px rgba(45, 156, 255, 0.35);
  }
  .thumb:active {
    cursor: grabbing;
  }
  .thumb:focus-visible {
    outline: 2px solid #ffffff;
    outline-offset: 3px;
  }
  .quartz-chip {
    position: absolute;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 0.25rem 0.6rem;
    background: var(--accent);
    color: #001d36;
    border-radius: 999px;
    font-size: 0.7rem;
    font-weight: 700;
    letter-spacing: 0.12em;
    top: 50%;
    display: none;
  }
  .quartz-chip.visible {
    display: inline-flex;
  }
  .slider-info {
    display: grid;
    gap: 0.4rem;
    font-size: 0.9rem;
  }
  .deck button.secondary {
    background: #181818;
    border-radius: 0.6rem;
    border: 1px solid #2a2a2a;
    padding: 0.6rem 1rem;
    color: var(--text);
    cursor: pointer;
  }
  .made-by {
    position: fixed;
    bottom: 1rem;
    right: 1rem;
    background: rgba(45, 156, 255, 0.85);
    color: #041b2b;
    padding: 0.5rem 1rem;
    border-radius: 999px;
    font-weight: 700;
    letter-spacing: 0.12em;
    box-shadow: 0 4px 16px rgba(45, 156, 255, 0.45);
    z-index: 999;
  }
  @media (max-width: 768px) {
    .fader-track {
      height: 320px;
      width: 60px;
    }
    .thumb {
      width: 50px;
      height: 30px;
    }
    .tick::before {
      margin-left: 6px;
      width: 14px;
    }
    .tick.major::before {
      width: 22px;
    }
    .tick-label {
      margin-left: 34px;
      font-size: 0.7rem;
    }
  }
</style>
</head>
<body>
  <div class="made-by">Hecho por GuilTeach</div>
  <h1>Dual Deck Vinyl Tempo Helper</h1>
  <div class="app" aria-live="polite">
    <div class="top-controls">
      <button type="button" id="align-right" aria-label="Alinear tempo de la derecha con la izquierda">Alinear derecha ↦ izquierda</button>
      <button type="button" id="align-left" aria-label="Alinear tempo de la izquierda con la derecha">Alinear izquierda ↦ derecha</button>
      <button type="button" id="toggle-range" aria-pressed="false" aria-label="Cambiar rango de pitch entre ±10% y ±20%">Cambiar rango ±10%</button>
      <span class="range-label" id="range-label">Rango actual: ±10.00%</span>
    </div>
    <div class="decks">
      <section class="deck" id="deck-left" aria-label="Deck izquierdo">
        <header>
          <h2>Deck Izquierda</h2>
          <div class="tempo-display">
            <span>BPM original</span>
            <strong><span class="bpm-value">120.00</span> BPM</strong>
            <span>Tempo actual: <span class="tempo-actual">120.00</span> BPM</span>
            <span>Objetivo: <span class="tempo-objetivo">120.00</span> BPM</span>
            <span class="pitch-legend">±0.00% desde el centro</span>
            <span>Offset físico: <span class="offset-value">0.00%</span></span>
            <span>Notch actual: <span class="notch-value">0.00%</span></span>
          </div>
        </header>
        <div class="bpm-control" aria-label="Control de BPM original">
          <button type="button" class="bpm-down" aria-label="Disminuir BPM">−</button>
          <input type="number" class="bpm-input" min="30" max="300" step="0.01" aria-label="Editar BPM original" />
          <button type="button" class="bpm-up" aria-label="Aumentar BPM">+</button>
        </div>
        <div class="slider-area">
          <div class="fader" data-deck="left">
            <div class="fader-track" aria-hidden="true">
              <div class="track-inner"></div>
              <div class="ghost-line" aria-hidden="true"></div>
              <div class="extreme top">−</div>
              <div class="extreme bottom">+</div>
            </div>
            <div class="quartz-chip" aria-hidden="true">QUARTZ LOCK</div>
            <div class="thumb" tabindex="0" role="slider" aria-label="Fader de tempo" aria-valuemin="-10" aria-valuemax="10" aria-valuenow="0">0%</div>
          </div>
        </div>
        <div class="slider-info">
          <button type="button" class="secondary calibrate" aria-label="Calibrar cero físico con la posición actual">Calibrar cero físico</button>
          <button type="button" class="secondary reset" aria-label="Restablecer offset a cero">Restablecer offset</button>
        </div>
      </section>
      <section class="deck" id="deck-right" aria-label="Deck derecho">
        <header>
          <h2>Deck Derecha</h2>
          <div class="tempo-display">
            <span>BPM original</span>
            <strong><span class="bpm-value">120.00</span> BPM</strong>
            <span>Tempo actual: <span class="tempo-actual">120.00</span> BPM</span>
            <span>Objetivo: <span class="tempo-objetivo">120.00</span> BPM</span>
            <span class="pitch-legend">±0.00% desde el centro</span>
            <span>Offset físico: <span class="offset-value">0.00%</span></span>
            <span>Notch actual: <span class="notch-value">0.00%</span></span>
          </div>
        </header>
        <div class="bpm-control" aria-label="Control de BPM original">
          <button type="button" class="bpm-down" aria-label="Disminuir BPM">−</button>
          <input type="number" class="bpm-input" min="30" max="300" step="0.01" aria-label="Editar BPM original" />
          <button type="button" class="bpm-up" aria-label="Aumentar BPM">+</button>
        </div>
        <div class="slider-area">
          <div class="fader" data-deck="right">
            <div class="fader-track" aria-hidden="true">
              <div class="track-inner"></div>
              <div class="ghost-line" aria-hidden="true"></div>
              <div class="extreme top">−</div>
              <div class="extreme bottom">+</div>
            </div>
            <div class="quartz-chip" aria-hidden="true">QUARTZ LOCK</div>
            <div class="thumb" tabindex="0" role="slider" aria-label="Fader de tempo" aria-valuemin="-10" aria-valuemax="10" aria-valuenow="0">0%</div>
          </div>
        </div>
        <div class="slider-info">
          <button type="button" class="secondary calibrate" aria-label="Calibrar cero físico con la posición actual">Calibrar cero físico</button>
          <button type="button" class="secondary reset" aria-label="Restablecer offset a cero">Restablecer offset</button>
        </div>
      </section>
    </div>
  </div>
<script>
  // Formateador numérico con configuración española
  const formatPercent = new Intl.NumberFormat('es-ES', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  const formatBpm = new Intl.NumberFormat('es-ES', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

  const state = {
    range: 0.10,
    decks: {
      left: {
        id: 'left',
        bpm: 120,
        pNom: 0,
        offset: 0,
        elements: null
      },
      right: {
        id: 'right',
        bpm: 120,
        pNom: 0,
        offset: 0,
        elements: null
      }
    }
  };

  // buildTicks(trackEl, range): genera las marcas y etiquetas según el rango seleccionado
  function buildTicks(trackEl, range) {
    // Limpia y reconstruye por completo el carril de marcas según el rango activo
    const inner = trackEl.querySelector('.track-inner');
    inner.innerHTML = '';
    const total = range * 100;
    const step = 1; // marcas cada 1%
    for (let percent = -total; percent <= total + 0.001; percent += step) {
      const tick = document.createElement('div');
      tick.className = 'tick';
      const position = (percent + total) / (2 * total);
      tick.style.top = `${position * 100}%`;
      if (Math.abs(percent) < 0.0001) {
        tick.classList.add('zero');
      }
      if (Math.round(Math.abs(percent)) % 2 === 0) {
        tick.classList.add('major');
        const label = document.createElement('span');
        label.className = 'tick-label';
        const sign = percent > 0 ? '+' : percent < 0 ? '−' : '';
        label.textContent = `${sign}${formatPercent.format(Math.abs(percent))}%`;
        tick.appendChild(label);
      }
      inner.appendChild(tick);
    }
  }

  function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }

  // effectivePitch(pNom, offset): devuelve el pitch efectivo considerando la calibración
  function effectivePitch(pNom, offset) {
    // Calcula el pitch efectivo respetando la tolerancia de bloqueo de cuarzo
    const diff = pNom - offset;
    return Math.abs(diff) <= 0.001 ? 0 : diff;
  }

  // snapPitch(pNom, offset): aplica el snap al soltar si la desviación es mínima
  function snapPitch(pNom, offset) {
    // Ajusta el pitch nominal al offset si se encuentra dentro de la zona de snap
    const diff = pNom - offset;
    return Math.abs(diff) <= 0.0015 ? offset : pNom;
  }

  function computeTempo(deck) {
    const pEff = effectivePitch(deck.pNom, deck.offset);
    return deck.bpm * (1 + pEff);
  }

  function getOtherDeckId(deckId) {
    return deckId === 'left' ? 'right' : 'left';
  }

  function updateRangeUI() {
    const label = document.getElementById('range-label');
    const toggle = document.getElementById('toggle-range');
    const current = state.range * 100;
    label.textContent = `Rango actual: ±${formatPercent.format(current)}%`;
    toggle.textContent = `Cambiar rango ±${current === 10 ? '20' : '10'}%`;
    toggle.setAttribute('aria-pressed', current === 20 ? 'true' : 'false');
    document.querySelectorAll('.fader-track').forEach(track => buildTicks(track, state.range));
    Object.values(state.decks).forEach(deck => updateDeckUI(deck.id));
  }

  function positionFromPitch(pNom) {
    // mapping: convierte el pitch nominal a una posición normalizada (0-1) dentro del carril
    const range = state.range;
    const normalized = (pNom + range) / (2 * range);
    return clamp(normalized, 0, 1);
  }

  function pitchFromPosition(position) {
    // mapping inversa: traduce la posición del carril al valor de pitch nominal
    const range = state.range;
    return -range + position * 2 * range;
  }

  function updateThumbPosition(deck, animate = false) {
    const { thumb, track } = deck.elements;
    const trackRect = track.getBoundingClientRect();
    const height = trackRect.height;
    const position = positionFromPitch(deck.pNom);
    const y = position * height;
    thumb.style.top = `${y}px`;
    const thumbPercent = deck.pNom * 100;
    const thumbSign = deck.pNom > 0 ? '+' : deck.pNom < 0 ? '−' : '';
    thumb.textContent = `${thumbSign}${formatPercent.format(Math.abs(thumbPercent))}%`;
    thumb.setAttribute('aria-valuemin', (-state.range * 100).toFixed(0));
    thumb.setAttribute('aria-valuemax', (state.range * 100).toFixed(0));
    thumb.setAttribute('aria-valuenow', (deck.pNom * 100).toFixed(2));
  }

  function updateGhost(deck) {
    const ghost = deck.elements.ghost;
    const otherDeck = state.decks[getOtherDeckId(deck.id)];
    const targetTempo = computeTempo(otherDeck);
    const pEffNeeded = targetTempo / deck.bpm - 1;
    const unclamped = pEffNeeded + deck.offset;
    const pNomNeeded = clamp(unclamped, -state.range, state.range);
    const trackRect = deck.elements.track.getBoundingClientRect();
    const height = trackRect.height;
    const position = positionFromPitch(pNomNeeded);
    ghost.style.top = `${position * height}px`;
    ghost.style.opacity = Math.abs(unclamped) > state.range ? 0.25 : 0.6;
    ghost.style.display = 'block';
  }

  function updateQuartzChip(deck) {
    const chip = deck.elements.chip;
    const pEff = effectivePitch(deck.pNom, deck.offset);
    chip.classList.toggle('visible', Math.abs(pEff) === 0);
  }

  function updateDeckUI(deckId) {
    const deck = state.decks[deckId];
    const tempo = computeTempo(deck);
    const otherTempo = computeTempo(state.decks[getOtherDeckId(deckId)]);
    const container = deck.elements.container;
    container.querySelector('.bpm-value').textContent = formatBpm.format(deck.bpm);
    container.querySelector('.tempo-actual').textContent = formatBpm.format(tempo);
    container.querySelector('.tempo-objetivo').textContent = formatBpm.format(otherTempo);
    const pitchLegend = deck.pNom * 100;
    const pitchSign = deck.pNom > 0 ? '+' : deck.pNom < 0 ? '−' : '';
    container.querySelector('.pitch-legend').textContent = `${pitchSign}${formatPercent.format(Math.abs(pitchLegend))}% desde el centro`;
    const offsetPercent = deck.offset * 100;
    const offsetSign = deck.offset > 0 ? '+' : deck.offset < 0 ? '−' : '';
    container.querySelector('.offset-value').textContent = `${offsetSign}${formatPercent.format(Math.abs(offsetPercent))}%`;
    const notch = (deck.pNom - deck.offset) * 100;
    const notchSign = notch > 0 ? '+' : notch < 0 ? '−' : '';
    container.querySelector('.notch-value').textContent = `${notchSign}${formatPercent.format(Math.abs(notch))}%`;
    const bpmInput = container.querySelector('.bpm-input');
    bpmInput.value = formatBpm.format(deck.bpm);
    updateThumbPosition(deck);
    updateGhost(deck);
    updateQuartzChip(deck);
  }

  function setPitch(deckId, pNom, { snap = false } = {}) {
    const deck = state.decks[deckId];
    deck.pNom = clamp(pNom, -state.range, state.range);
    if (snap) {
      deck.pNom = snapPitch(deck.pNom, deck.offset);
    }
    updateDeckUI(deckId);
    updateDeckUI(getOtherDeckId(deckId));
  }

  function nudgePitch(deckId, delta) {
    const deck = state.decks[deckId];
    setPitch(deckId, deck.pNom + delta);
  }

  // adjustBpmPreservingTempo(deck, newBpm): mantiene el tempo actual al editar el BPM original
  function adjustBpmPreservingTempo(deck, newBpm) {
    // Recalcula el BPM base manteniendo el tempo resultante y recoloca el fader
    const tempoPrev = computeTempo(deck);
    deck.bpm = clamp(newBpm, 30, 300);
    const pEffNuevo = tempoPrev / deck.bpm - 1;
    deck.pNom = clamp(pEffNuevo + deck.offset, -state.range, state.range);
  }

  // alignTempos(fixedDeckId): el deck fijado permanece y el otro se ajusta
  function alignTempos(fixedDeckId) {
    // Utiliza el tempo del deck de referencia y desplaza el fader del otro deck
    const fixed = state.decks[fixedDeckId];
    const movingId = getOtherDeckId(fixedDeckId);
    const moving = state.decks[movingId];
    const tempoTarget = computeTempo(fixed);
    const pEffNeeded = tempoTarget / moving.bpm - 1;
    const pNomNeeded = clamp(pEffNeeded + moving.offset, -state.range, state.range);
    moving.pNom = pNomNeeded;
    updateDeckUI(movingId);
    updateDeckUI(fixedDeckId);
  }

  function initializeDeck(deckId) {
    const deck = state.decks[deckId];
    const container = document.getElementById(`deck-${deckId}`);
    deck.elements = {
      container,
      bpmInput: container.querySelector('.bpm-input'),
      bpmUp: container.querySelector('.bpm-up'),
      bpmDown: container.querySelector('.bpm-down'),
      track: container.querySelector('.fader-track'),
      thumb: container.querySelector('.thumb'),
      ghost: container.querySelector('.ghost-line'),
      chip: container.querySelector('.quartz-chip'),
      calibrate: container.querySelector('.calibrate'),
      reset: container.querySelector('.reset')
    };
    deck.elements.bpmUp.addEventListener('click', () => {
      adjustBpmPreservingTempo(deck, deck.bpm + 0.1);
      updateDeckUI(deckId);
      updateDeckUI(getOtherDeckId(deckId));
    });
    deck.elements.bpmDown.addEventListener('click', () => {
      adjustBpmPreservingTempo(deck, deck.bpm - 0.1);
      updateDeckUI(deckId);
      updateDeckUI(getOtherDeckId(deckId));
    });
    deck.elements.bpmInput.addEventListener('change', event => {
      const value = parseFloat(event.target.value.replace(',', '.'));
      if (!Number.isFinite(value)) {
        event.target.value = formatBpm.format(deck.bpm);
        return;
      }
      adjustBpmPreservingTempo(deck, value);
      updateDeckUI(deckId);
      updateDeckUI(getOtherDeckId(deckId));
    });

    const thumb = deck.elements.thumb;
    const track = deck.elements.track;

    const pointerHandler = {
      active: false,
      start(event) {
        event.preventDefault();
        this.active = true;
        thumb.setPointerCapture(event.pointerId);
        this.move(event);
      },
      move(event) {
        if (!this.active) return;
        const rect = track.getBoundingClientRect();
        const y = clamp(event.clientY - rect.top, 0, rect.height);
        const position = y / rect.height;
        const pNom = pitchFromPosition(position);
        setPitch(deckId, pNom);
      },
      end(event) {
        if (!this.active) return;
        this.active = false;
        thumb.releasePointerCapture(event.pointerId);
        setPitch(deckId, state.decks[deckId].pNom, { snap: true });
      }
    };

    thumb.addEventListener('pointerdown', event => pointerHandler.start(event));
    thumb.addEventListener('pointermove', event => pointerHandler.move(event));
    thumb.addEventListener('pointerup', event => pointerHandler.end(event));
    thumb.addEventListener('pointercancel', event => pointerHandler.end(event));

    track.addEventListener('pointerdown', event => {
      const rect = track.getBoundingClientRect();
      const y = clamp(event.clientY - rect.top, 0, rect.height);
      const position = y / rect.height;
      const pNom = pitchFromPosition(position);
      setPitch(deckId, pNom);
      setPitch(deckId, state.decks[deckId].pNom, { snap: true });
    });

    thumb.addEventListener('keydown', event => {
      if (event.key !== 'ArrowUp' && event.key !== 'ArrowDown') return;
      event.preventDefault();
      const multiplier = event.shiftKey ? 0.001 : 0.0001;
      const delta = event.key === 'ArrowUp' ? -multiplier : multiplier;
      nudgePitch(deckId, delta);
    });

    thumb.addEventListener('keyup', event => {
      if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
        setPitch(deckId, state.decks[deckId].pNom, { snap: true });
      }
    });

    deck.elements.calibrate.addEventListener('click', () => {
      deck.offset = deck.pNom;
      updateDeckUI(deckId);
      updateDeckUI(getOtherDeckId(deckId));
    });

    deck.elements.reset.addEventListener('click', () => {
      deck.offset = 0;
      updateDeckUI(deckId);
      updateDeckUI(getOtherDeckId(deckId));
    });

    updateDeckUI(deckId);
  }

  document.getElementById('toggle-range').addEventListener('click', () => {
    state.range = state.range === 0.10 ? 0.20 : 0.10;
    updateRangeUI();
  });

  document.getElementById('align-right').addEventListener('click', () => alignTempos('left'));
  document.getElementById('align-left').addEventListener('click', () => alignTempos('right'));

  initializeDeck('left');
  initializeDeck('right');
  updateRangeUI();
  window.addEventListener('resize', () => {
    Object.keys(state.decks).forEach(id => updateDeckUI(id));
  });
</script>
</body>
</html>
